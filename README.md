# Azure APIM, LogicApps & Functions Automation

## Automation PowerShell Scripts & ARM templates to deploy an Azure Application that uses various server-less components like Azure API management, Azure Logic apps & Azure Functions.

### These automation scripts can be used to link various server-less components, apply advanced API & operation policies to Azure API management, link logic apps as backend url for an API management operation & link service bus with an existing function and get the function trigger URL which can be used by logic apps / any other workflow to trigger.

Before deploying the automation scripts the following pre-requisite steps are to carried out.

## Prerequisites:

1. Configure Azure PaaS components:

* Ensure that the target Azure subscription has a resource group set up with a service principal having contributor access to the same.
* Provision an Azure function with http trigger (and custom code).
* Provision a service bus queue.
* Provision a logic app with http rest trigger (and custom logic).

2. Configure json configuration files:

2.1. Open the **APIMDeploy.parameters.dev.json** file : this file defines the ARM template parameters for API management service and other PaaS components required. Configure the following parameters:

* **service_apim_name** : API Management Service name
* **apim_location** : APIM Location
* **publisher_email** : Publisher email Id
* **publisher_name** : Publisher Name
* **sku_name** : Desired SKU of APIM
* **vntResourceGroup** : Virtual Network Resource group name
* **vntName** : Virtual Network name
* **subnetName** : Subnet name
* **omsName** : Operations management suite name
* **omsLocation** : OMS Location
* **omsTier** : Desired OMS Tier
* **notificationHubNamespaceName** : Notification Hub namespace name
* **notificationHubName** : Notification Hub name
* **notificationHubSkuName** : Desired Notification hub SKU
* **storageAccountName** : Storage account name for Azure Function
* **functionapp_name** : Azure Function app name
* **service_plan_name** : App service plan name for Azure Function App

2.2. Open the **APIMPolicyConfig.dev.json** file : This file contains rate limiting policy for all API operations and renewal period for the same. This file will be used by our target deployment scripts. In order to add / modify the policy for each API operation perform the following : 

* Add element to the **operations** array & initialize it with **Name** and **Call** properties representing the name of the API operation and the call limit for the same respectively.
* Also make requisite changes to **calls** & **renewalperiod** properties of the **ratelimit** object to set the maximum calls and renewal period for the rate limiting policy respectively. One can also set the maximum calls allowed at the API level by modifying the **calls** property in the **api** object.

2.3. Open the **DeploymentConfig.dev.json** file : This file contains all the necessary configuration values for a given environment that will be used by the deployment scripts to configure various operations in the API’s. This file will be used by our target deployment scripts. In order to set the configuration values modify the following variables:

* **ResourceGroupName** : Name of Azure resource group for the environment
* **APIMServiceName** : API Management service name
* **CRMAPIName** : CRM API Name
* **CRMAPIPath** : API Path for CRM API
* **CRMProductTitle** : Product title for CRM API
* **GetTransactionsHistoryLogicAppName** : The name of get transaction history logic app
* **OriginUrls** : Array of strings which have URL’s that are to be allowed by API’s in CORS policy, each URL is comma separated
* **GetPiiDataBackend** : Get Pii data backend URL
* **CRMProductAdminEmail** : CRM Product Admin Email address

3. The **BasePolicies.wadl.xml** & **APIMBasePolicies.wadl.xml** files will be used as a generic template for APIM operation policies in a given API and policies at API level respectively. Do not modify these files as they will be dynamically generated by automation scripts based on the configuration from **DeploymentConfig.dev.json** file and the policies required by the API operation and the API.

## Script Execution:

### Now that the prerequisite steps are performed, we can execute the deployment scripts.

1. Deploy the ARM template **APIMDeploy.json** with the parameters file selected as **APIMDeploy.parameters.dev.json**. It will deploy the following PaaS components : 

* A storage account for Azure Function (logs and diagnostic dumps)
* A web service plan 
* A web app for Azure Function configured with the storage account
* Azure API Management service hosted on provided Virtual Network in Azure & configured with OMS logs with an existing OMS dashboard
* An OMS service with dashboard configured with Logic Apps solution template.
* An Azure Notification Hub

2. Execute the **AzureFunctionConfig.ps1** with the following arguments:

* **ResourceGroupName** : Resource group name
* **ParamFilePath** : API Management ARM template parameter file path
* **LogicAppParamFilePath** : Logic App ARM template parameter file path
* **Environment** : Environment Identifier

This script main purpose is to obtain function trigger url (assuming the function code with http trigger is published to the web app). One can skip this script and proceed to step 3 with a hardcoded URL. The following steps are performed:

2.1. Logs into Azure environment, parses the **APIMDeploy.parameters.dev.json** file to get the function app name.
2.2. The script also parses a json parameter file for logic app arm template service bus namespace name and service bus queue name, feel free to modify it to hardcode these values or configure to read from other json files.
2.3. It then generates a SaS token (valid for 2 years) for the service bus queue.
2.4. The service bust url, SaS token, queue url etc is then pushed to Azure function app settings.
2.5. Finally the script gets the Master key for the function by using the credentials from publish profile and & function app service scm azurewebsite, the master key is then used to obtain the function key & finally the value of function trigger url is populated.

3. Execute the **deploymentScript.ps1** with the following arguments:

* **PolicyFilePath** : File path of **BasePolicies.wadl.xml** relative to execution directory
* **APIMPolicyFilePath** : File path of **APIMBasePolicies.wadl.xml** relative to execution directory
* **APIMPolicyConfigFilePath** : File path of **APIMPolicyConfig.dev.json** relative to execution directory
* **ConfigurationFilePath** : File path of **DeploymentConfiguration** folder relative to execution directory
* **Environment** : Environment Identifier 
* **ClientId** : Client ID of service principal AD app
* **resourceAppIdURI** : Resource App Id URI of service principal AD app
* **TenantId** : Tenant Id of Azure AD
* **ClientKey** : Client key of service principal AD app
* **NotificationFunctionBackend** : Azure function trigger URL (as obtained from previous step / hardcode to the url)
* **SubscriptionID** : Azure Subscription Id

This script logs into Azure environment and parses the **DeploymentConfig.dev.json** to load the deployment configuration values and call the **CreateCRMAPI.ps1** with the same.

3.1. **CreateCRMAPI.ps1** : This is the main deployment script which will deploy the API to API management service. In this case a new API with several operations, policies are created and published to a product with admins defined for the product. The following steps are executed by the script:

* The script dot sources the 2 scripts **UpdatePolicies.ps1** & **SetAPIMPolicy.ps1** as the functions in the 2 scripts will be frequently used by it.
* The script then gets the product for the new API (assuming the product with the configured name already exists in the API management service), creates a new API if it does not already exist in the product and publishes it to the product.
* Creates new user account, ad it to a new user group, adds the user group to product & publishes it.
* Creates a new API management subscription at the product level.

* It then calls the **CreateProductPolicy** function in the dot sourced **SetAPIMPolicy.ps1**
* This function creates a new xml wadl policy definition file with the renewal period and rate limit values from  **APIMPolicyConfig.dev.json**.

* It then upserts the first operation in the API 
* The header values, url parameters & other operation properties can be modified here.

* Once the operation is created the **setPolicies** function in the dot sourced **UpdatePolicies.ps1** script is called.
* This function takes the following inputs:
* OperationName : the operation name
* LogicAppName : the logic app name intended to be set as the operation's backend
* ResourceGroupName : the resource group name
* APIMServiceName : the API management service name
* APIName : the API name
* PolicyFilePath : policy file path of the **BasePolicies.wadl.xml**
* PathPrefix : url relative path prefix
* OriginUrls : origin url's to be whitelisted
* CacheParams : Cache parameters for the operation
* BackendUrl : Backend url for the operation
* EnableRetry :Enable retry flag

* Based on the parameters the **BasePolicies.wadl.xml** is populated for the current operation with the policies corresponding to the desired configuration provided to the **setPolicies** function. The function performs the following steps:
1. Creates API context and get API and current operations details (will be used further).
2. Parses the **BasePolicies.wadl.xml** and removes all xml elements.
3. Add baseline policy tags as xml elements in the file.
4. If **BackendUrl** is provided for current operation, the **set-backend-service** policy is added with the backend url configured to the provided address.
5. If **OriginUrls** are provided for current operation, the **cors** policy is added with the the given url's added to **origin** element in **allowed-origins** object. Also the **allowed-methods** & **allowed-headers** are set to * which means that all methods and types of headers are accessible, one can configure certain methods / header for each url here.
6. If **CacheParams** are provided for current operation, the **cache-lookup** policy is added with the **vary-by-query-parameter** initialized with all parameters that require caching. Other properties like **cache-store duration**, **vary-by-header** etc can be configured here.
7. If **EnableRetry** is provided for current operation, the **retry** policy is added with **retry count, interval** & other properties initialized.
8. If **LogicAppName** is provided the the **rewrite-uri** policy is created by the following steps:
* The xml element with dummy logic app linking template with **rewrite-uri** policy is created. This template will be updated dynamically with actual configuration for the given logic app.
* Then the logic app reference is obtained.
* A graph request is made to obtain the logic app's http rest trigger's callbakurl.
* This rest call trigger url & signature. The signature is like a secret required along with trigger url in order to invoke the logic app. This signature must not be revealed, so in order to securely store and reference it, the same is stored as an API Management Property (stores any value as a secret in API management service).
* Now the xml element holding the dummy logic app template for **rewrite-uri** policy is updated to point to trigger url of the current logic app's trigger and refer its signature by pointing to the newly created API management property storing the same as a secret.
* It also modifies a json template comment in the xml element which holds the ARM reference of the logic app to complete the http rest trigger's mapping with the desired logic app. Without this, the policy will never know which logic app's trigger to rewrite the backend url to.
* Finally the xml file is saved & the policy is applied to the operation.

* The script then calls the **SetOperationPolicy** function in the dot sourced **SetAPIMPolicy.ps1**
* This function creates a new xml wadl policy definition file with the rate limit value from  **APIMPolicyConfig.dev.json** & applies the rate limit policy to the operation.

* The script then creates rest of the operations in the API along with their properties, definitions and policies.

* Finally **WritePolicyToProduct** function in the dot sourced **SetAPIMPolicy.ps1**
* This function writes the xml wadl policy definition file created previously by the **CreateProductPolicy** function & applies the policy to the product.
